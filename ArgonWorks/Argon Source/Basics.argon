///
///
///
///
///
///

MAIN MODULE Basics
    {
    ///
    ///
    /// Macros are defined and "live" in the module they are defined in. Macros
    /// can be referenced from both inside and outside their home module and can be applied
    /// outside their home module if they are imported by means of an import of their
    /// home module.
    ///
    /// Macro parameters must be quoted as per normal if they are strings.
    /// Macro parameters may be used inside the macro text in one of two ways
    /// in a quoted form or an unquoted form. In the normal quoted form the
    /// parameter is referenced in the macro text by prefixing the name
    /// name of the parameter with a '%' ( percent ) symbol, in that case if
    /// the argument to the parameter contains a string the string will be substituted
    /// into the macro text surrounded by double quotes, for example, if a macro is
    /// declared as
    ///
    /// MACRO SomeMacro(Parm1)
    ///     $$
    ///     this is macro text
    ///     %Parm1
    ///     $$
    ///
    /// and the Parm1 parameter is referenced in the macro text as '%Parm1',
    /// when the Parm1 parameter has an argument passed to it that is a string, say '"string"',
    /// then the contents of the string will be substited in as
    ///
    /// MACRO SomeMacro(Parm1)
    ///     $$
    ///     this is macro text
    ///     "string"
    ///     $$
    ///
    /// If on the other hand the Parm1 parameter is reference with the unquoted
    /// operator, '%%' ( two percent symbols ) as in
    ///
    /// MACRO SomeMacro(Parm1)
    ///     $$
    ///     this is macro text
    ///     %Parm1
    ///     $$
    /// then the string argument will be substituted into the macro text without
    /// double quotes, as 'string' as in
    ///
    /// MACRO SomeMacro(Parm1)
    ///     $$
    ///     this is macro text
    ///     string
    ///     $$
    ///
    /// It is important not to confuse the two macro parameter operators as they
    /// have radically different effects.
    ///
    /// Because macros are substituted into the source text, they can not traditionally be debugged
    /// since we only see the invocation of the macro in the source code. However Argon uses the concept
    /// of "tiered" line numbers where the line nmber of the invocation of the macro is prefixed
    /// to the line number of the macro source, thus allowing the debugger to keep track of both
    /// it's position in the source where the macro is invoked and the source of the macro itself.
    /// Macro invocations can be nested inside other macros and the debugger supports these too.
    ///
    /// Macros are subject to the same visibility modifiers as any object in the Argon name space
    /// and so can be made PUBLIC, PRIVATE or EXPORTED, the same as METHODs, MODULEs, CLASSes and TYPEs.
    /// Macros that are EXPORTED and PUBLIC can be used outside their defining MODULE, depending on
    /// the exact visibility modifier of course.
    ///
    /// If you wish to use a macro in some other MODULE, IMPORT that MODULE the same way you would
    /// to import any other object, once the MODULE has been imported the macros from that MODULE
    /// will be available to you the same way any other object from that MODULE is.
    ///
    ///
    
///    MACRO Macro1(AParm,BParm,CParm,DParm)
///        ${
///        EXPORTED METHOD %AParm(argument::%BParm)  -> %CParm
///            {
///            LET value = %CParm()
///            print(%%DParm)
///            RETURN(value)
///            }
///        }$
    
    CONSTANT $MacroCount = 3
    
    SLOT basicSlot = "This is a module based slot"
    
    CONSTANT $NumericConstantNumber1 = 12.78876554
    CONSTANT $NumericConstantNumber2 = 189567
    
///    Macro1("NameNumber1","Integer","String",String)
///    Macro1("Number","Float","Array<String>",Integer)
    PUBLIC CLASS AGenericClass<ELEMENT,INDEXTYPE>::Object
        {
        SLOT elements::Array<ELEMENT> = Array<ELEMENT>()
        SLOT index::INDEXTYPE
        }
        
    PUBLIC CLASS Box<VALUE>
        {
        SLOT value::VALUE
        }
        
    PUBLIC CLASS NamedBox<NAME>::Box
        {
        SLOT name::NAME
        SLOT second::VALUE
        }
        
    PUBLIC CLASS NamedSlotBox<SLOTKIND>::NamedBox
        {
        SLOT slotValue::SLOTKIND
        SLOT thirdSlot::VALUE
        SLOT secondName::NAME
        }
        
    SLOT moduleClassSlot::AGenericClass<Integer,Float> = AGenericClass<Integer,Float>()
    
    PUBLIC TYPE IntegerFloatThing IS AGenericClass<Integer,Float>
    
    MAIN METHOD begin()
        {
        doTheThing()
        runOfTheMill(with::things)
        LET result = createTheWidget()
        doWhatIsHard()
        returnToTheMoon()
        }
        
    PUBLIC ENUMERATION PersonState::Integer
        {
        #legal(Integer,String) = 1
        #natural(String) = 2
        #sovereign(Person) = 3
        }
    ///
    ///
    /// Entity is a root class because it inherits
    /// from nothing, in reality it actually inherits
    /// from Object because all classes must
    ///
    ///
    CLASS Entity
        {
        SLOT name::String = "Entity Name"
        SLOT identityNumber::String = ""
        SLOT age::Integer = 47
        SLOT isSovereign?::Boolean = #false
        
        CLASS SLOT overEverything = "This is some text"
        }
        
    CLASS LegalEntity::Entity
        {
        }
        
    CLASS Corporate::LegalEntity
        {
        }
        
    CLASS SovereignState::LegalEntity
        {
        }
        
    CLASS Person::LegalEntity
        {
        SLOT firstName::String
        }
    ///
    ///
    /// A TYPE is an alias for some TYPE construct defined
    /// elsewhere in the system. Typically a TYPE is defined
    /// as a shortcut for more complicated types.
    ///
    ///
    TYPE PersonList IS Array<Person>
    TYPE Sovereign IS SovereignState
    
    METHOD string(from::Integer) -> String
    		{
    		RETURN(_IntegerToString(from))
    		}
    
    METHOD print(=string::String) -> Integer
    		{
    		RETURN(0)
    		}
    
    METHOD closureGenerator() -> (Integer,Integer) -> String
        {
        LET closure =
            {
            WITH(int1::Integer,int2::Integer) -> String
            LET string1 = string(from:: int1)
            LET string2 = string(from:: int2)
            print(Entity->overEverything)
            RETURN(string1 + string2)
            }
        RETURN(closure)
        }
        
    METHOD testingThings(argument::Object) -> Object
        {
        Basics->basicSlot = $NumericConstantNumber1
        LET name = "Jones"
        LET person = Person()
        person->firstName = name
        person->name = "Some Person or Other"
        person->identityNumber = "650103093888288288"
        person->age = 101
        person->age++
        HANDLE(#InvalidInvocation)
            {
            WITH(symbolName)
            print("A symbol was raised")
            print(symbolName)
            }
        begin()
        RETURN(Object())
        }
        
    METHOD print(=thing::Corporate) -> Integer
        {
        LET argument = Object()
        testingThings(argument::argument)
        RETURN(1)
        }
        
    METHOD print(=string::String)
        {
        LET stream = open("/stdout","wt")
        write(stream,string)
        close(stream)
        }
        
    METHOD print(=integer::Integer)
        {
        LET stream = open("/stdout","wt")
        write(stream,integer)
        close(stream)
        }
        
    METHOD print(=person::Person)
        {
        LET stream = open("/stdout","wt")
        write(stream,person)
        close(stream)
        }
        
    METHOD write()
        {
        LET stream = open("/file.bin","wb")
        write(stream,0)
        write(stream,"NAME")
        write(stream,"Vincent")
        write(stream,"AGE")
        write(stream,56)
        seek(stream,0,#true)
        write(2)
        close(stream)
        }
        
    METHOD selectiveSwinging(input::Integer) -> Float
        {
        IF input > 433 && (input < 47 || input > 19)
            {
            print("It floogled again")
            }
        ELSEIF input > 1000
            {
            print("So far so good")
            }
        ELSE
            {
            print("It's not looking good.")
            }
        SELECT(input)
            {
            WHEN(21)
                {
                RETURN(21.5)
                }
            WHEN(50)
                {
                RETURN(105.5)
                }
            WHEN(1000)
                {
                RETURN(2005.5)
                }
            OTHERWISE
                {
                RETURN(0.1)
                }
            }
        RETURN(9.0)
        }
    
    ENUMERATION ClassType
        {
        #integer
        #float
        #string
        #symbol
        #character
        #byte
        #boolean
        #date
        #time
        #dateTime
        #symbol
        #enumeration
        #class
        #slot
        #module
        #other
        }
        
    ENUMERATION HumanityLevel
        {
        #psychopathic
        #sociopathic
        #narcissistic
        #indifferent
        #tolerant
        #sympathetic
        #loving
        #encouraging
        #divine
        }
        
    ENUMERATION BankState
        {
        #monstrous(HumanityLevel,String,Integer)
        #vicious(HumanityLevel,Person,Class)
        #uncaring(HumanityLevel,Symbol,Float)
        #normal
        }
        
    MODULE InnerModule
        {
        }
        
    SLOT thisIsAModuleSlot = BankState::#monstrous(HumantiyLevel::#psychopathoc,"Nedbank",23)
        
    METHOD finalMethod()
        {
        Basics::thisIsAModuleSlot = BankState::#monstrous(HumanityLevel::psychopathic,"Anything",900)
        LET someThing = Basics::BankState::#normal
        LET someModule = Basics::InnerModule
        LET method = Basics::finalMethod
        LET person = Person()
        LET entity = person AS Entity
        LET array = Array<Integer>()
        array[0] = 1
        LET someValue = array[0]
        print(person)
        }
        
MODULE Secondary(/Users/vincent/Desktop/libXenon.dylib)
    {
    FUNCTION(PrintString) printString(string::String) -> Void
    FUNCTION(CountArrayElements) countArrayElements(array::Array<String>) -> Integer
    FUNCTION(ElementAtKey) elementAtKey(dictionary::Dictionary<String,Object>) -> Integer
    }
    }
