//
//  StaticString.swift
//  ArgonWorks
//
//  Created by Vincent Coetzee on 17/12/21.
//

import Foundation

///
///
/// A static object holds some kind of object generated by the compiler that
/// will have an address assigned to it at some point. We need an object to hold
/// these things so we can have a shared address for them rather than having an
/// address assigned to each instance. A static string is a good example, we don't
/// want every use of the same static string to have a separate address assigned to
/// it, we want one string to have one address shared amongst all the places that
/// use it.
///
/// 
public class StaticObject: NSObject,NSCoding
    {
    public var segmentType: Segment.SegmentType
        {
        .static
        }
        
    public var sizeInBytes: Int
        {
        return(0)
        }
        
    public var extraSizeInBytes: Int
        {
        0
        }
        
    public var displayString: String
        {
        "StaticObject()"
        }

    internal var container: Container = .none
    internal var memoryAddress: Address = 0
    internal var wasAddressAllocationDone = false
    internal var wasMemoryLayoutDone = false
    
    public required init?(coder: NSCoder)
        {
        self.memoryAddress = Address(coder.decodeInteger(forKey: "memoryAddress"))
        }
    
    public override init()
        {
        super.init()
        }
        
    public func encode(with coder: NSCoder)
        {
        coder.encode(Int(self.memoryAddress),forKey: "memoryAddress")
        }
        
    public func type(inContext context: TypeContext) -> Type
        {
        fatalError()
        }
        
   public func allocateAddresses(using allocator: AddressAllocator) throws
        {
        guard !self.wasAddressAllocationDone else
            {
            return
            }
        self.wasAddressAllocationDone =  true
        allocator.allocateAddress(for: self)
        }
    }
    
public class StaticString: StaticObject
    {
    public static func == (lhs: StaticString, rhs: StaticString) -> Bool
        {
        lhs.string == rhs.string && lhs.memoryAddress == rhs.memoryAddress
        }
    
    public override var displayString: String
        {
        "StaticString(\(self.string))"
        }
        
    public override var sizeInBytes: Int
        {
        (self.container.argonModule.lookup(label: "String") as! Type).sizeInBytes
        }
        
    public override var extraSizeInBytes: Int
        {
        let count = self.string.utf16.count
        return(count * 2 + (count / 3 + 1) * 2)
        }
        
    internal let string: String
    
    init(string: String)
        {
        self.string = string
        super.init()
        }
        
    public required init?(coder: NSCoder)
        {
        self.string = coder.decodeObject(forKey: "string") as! String
        super.init(coder: coder)
        }
    
    public override func encode(with coder: NSCoder)
        {
        coder.encode(self.string,forKey: "string")
        super.encode(with: coder)
        }
    
    public override var hash: Int
        {
        var hasher = Hasher()
        hasher.combine("\(Swift.type(of: self))")
        hasher.combine(self.string)
        hasher.combine(self.memoryAddress)
        let hashValue = hasher.finalize()
        return(hashValue)
        }
        
    public override func type(inContext context: TypeContext) -> Type
        {
        context.stringType
        }
    }

public class StaticSymbol: StaticString
    {
    public override var displayString: String
        {
        "StaticSymbol(\(self.string))"
        }
        
    public override var hash: Int
        {
        var hasher = Hasher()
        hasher.combine("\(Swift.type(of: self))")
        hasher.combine(self.string)
        hasher.combine(self.memoryAddress)
        let hashValue = hasher.finalize()
        return(hashValue)
        }
        
    public override func type(inContext context: TypeContext) -> Type
        {
        context.symbolType
        }
    }

public class StaticArray: StaticObject
    {
    public enum ArrayElement: Hashable
        {
        case symbol(Symbol)
        case slot(Slot)
        case literal(Literal)
        case `class`(TypeClass)
        
        public var sizeInBytes: Int
            {
            switch(self)
                {
                case .literal(let literal):
                    return(literal.sizeInBytes)
                default:
                    return(Argon.kWordSizeInBytesInt)
                }
            }
            
        public var displayString: String
            {
            switch(self)
                {
                case .symbol(let symbol):
                    return(symbol.displayString)
                case .slot(let slot):
                    return(slot.displayString)
                case .literal(let literal):
                    return(literal.displayString)
                case .class(let aClass):
                    return(aClass.displayString)
                }
            }
            
        public func type(inContext context: TypeContext) -> Type?
            {
            switch(self)
                {
                case .symbol(let symbol):
                    return(symbol.type)
                case .slot(let slot):
                    return(slot.type)
                case .literal(let literal):
                    return(literal.type(inContext: context))
                case .class(let aClass):
                    return(aClass.type)
                }
            }
            
        public func encode(with coder: NSCoder,forKey: String)
            {
            switch(self)
                {
                case .symbol(let symbol):
                    coder.encode(1,forKey: forKey + "kind")
                    coder.encode(symbol,forKey: forKey + "symbol")
                case .slot(let slot):
                    coder.encode(2,forKey: forKey + "kind")
                    coder.encode(slot,forKey: forKey + "slot")
                case .literal(let literal):
                    coder.encode(3,forKey: forKey + "kind")
                    coder.encodeLiteral(literal,forKey: forKey + "literal")
                case .class(let aClass):
                    coder.encode(4,forKey: forKey + "kind")
                    coder.encode(aClass,forKey: forKey + "class")
                }
            }
            
        public init?(coder: NSCoder,forKey: String)
            {
            let kind = coder.decodeInteger(forKey: forKey + "kind")
            switch(kind)
                {
                case 1:
                    self = .symbol(coder.decodeObject(forKey: forKey + "symbol") as! Symbol)
                case 2:
                    self = .slot(coder.decodeObject(forKey: forKey + "slot") as! Slot)
                case 3:
                    self = .literal(coder.decodeLiteral(forKey: forKey + "literal"))
                case 4:
                    self = .class(coder.decodeObject(forKey: forKey + "class") as! TypeClass)
                default:
                    fatalError()
                }
            }
        }
        
    typealias ArrayElements = Array<ArrayElement>
    
    public override var sizeInBytes: Int
        {
        (self.container.argonModule.lookup(label: "Array") as! Type).sizeInBytes
        }
        
    public override var extraSizeInBytes: Int
        {
        let elementSize = self.elements.isEmpty ? Argon.kWordSizeInBytesInt : self.elements.first!.sizeInBytes
        let count = self.elements.count
        return(count * elementSize)
        }
        
    public override var displayString: String
        {
        let strings = self.elements.map{$0.displayString}.joined(separator: ",")
        return("StaticArray(\(strings))")
        }
        
    internal let elements: ArrayElements
    
    init(_ elements: ArrayElements)
        {
        self.elements = elements
        super.init()
        }
        
    init(_ classes: TypeClasses)
        {
        self.elements = classes.map{.class($0)}
        super.init()
        }
        
    init(_ slots: Slots)
        {
        self.elements = slots.map{.slot($0)}
        super.init()
        }
        
    init(_ symbols: Symbols)
        {
        self.elements = symbols.map{.symbol($0)}
        super.init()
        }
        
    init(_ literals: Array<Literal>)
        {
        self.elements = literals.map{.literal($0)}
        super.init()
        }
        
    public required init?(coder: NSCoder)
        {
        let count = coder.decodeInteger(forKey: "count")
        var items: Array<ArrayElement> = []
        for index in 0..<count
            {
            items.append(ArrayElement(coder: coder, forKey: "elements" + "\(index)")!)
            }
        self.elements = items
        super.init(coder: coder)
        }
    
    public override func encode(with coder: NSCoder)
        {
        coder.encode(self.elements.count,forKey: "count")
        var index = 0
        for element in self.elements
            {
            element.encode(with: coder, forKey: "elements" + "\(index)")
            index += 1
            }
        super.encode(with: coder)
        }
        
    public override var hash: Int
        {
        var hasher = Hasher()
        hasher.combine("\(Swift.type(of: self))")
        hasher.combine(self.elements)
        hasher.combine(self.memoryAddress)
        let hashValue = hasher.finalize()
        return(hashValue)
        }
        
    public override func type(inContext context: TypeContext) -> Type
        {
        let elementType = self.elements.isEmpty ? context.freshTypeVariable() : self.elements.first!.type(inContext: context)!
        return(context.arrayType.withGenerics([elementType]))
        }
    }
